---
title: 动态规划 挖地雷
comments: true
tags:
  - Algorithms
  - C++
  - 动态规划
categories:
  - C++
abbrlink: 2b89b1e1
date: 2019-04-22 20:20:35
mathjax: true
---

在一个地图上有n个地窖$ n \leq 200 $,每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径，并规定路径都是单向的,且保证都是小序号地窖指向在序号地窖，也不存在可以从一个地窖出发经过若干地窖后又回到原来地窖的路径。

某人可以从任一处开始挖地雷，然后沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使他能挖到最多的地雷。

<!-- more -->

# 输入
第一行：地窖的个数；  
第二行为依次每个地窖地雷的个数；  
下面若干行输入：
$ x, y $ 表示x可到y，且满足 $ x < y $
最后一行为"0 0"表示结束。

# 输出
$ k_{1} - k_{2} - \cdots - k_{n} $
$ total $

# 分析
从题目中我们可以看出这是一个经典的`DP`最短路径题目。因为每个地窖都只能单向通行，满足`DP`无后效性的原则。

## 状态转移方程
假设我们只要再走一次就到达了最后一个地窖，也就是最后一个阶段，有三条路给你选择，分别通往三个地窖，他们是$ 10, 20, 30 $，
你会选哪一条？当然是第3条啦！既然前面的地雷数已经确定了，那么决定总共挖地雷数量就是这里面最多的了。

按照这个思路，前面的最多的地雷数也是一样的，在通往下一个地窖时，选择地雷最多的地窖通行，就能挖出最多的地雷。所以，我们的状态转移方程就出来了：
$$
f[i] = max ( f[j] + c[i] )
$$
其中，$ f[i] $表示到第$ i $个地窖时挖出的地雷数，$ c[i] $表示第$ i $个地窖藏有的地雷数。

现在我们在考虑下边界条件。在题目中，每个地窖都应该会被计算过去，就会有一个`for`循环。那么又出现了一个问题，既然要计算挖到第`i`个地窖时挖出的地雷数量，怎么保证与`i`连通的地窖已经被计算过了呢？再认真看一看题目。

$ x, y $ 表示x可到y，且满足 $ x < y $

在输入的注释里我们发现$ x < y $，这就是一个隐含条件，我们需要从第$ n $个地窖开始计算，就能得出正确答案。  
边界条件：
$$
f[n] = c[n]
$$
最后，我们就再迭代整个$ f $数组，找到最大值即可。至于经过的路线，就用另外一个数字来储存。

## 数据结构设计
首先使用一个一维数组$ c $，来储存每个地窖所藏有的地雷数量。  
然后，根据题意，要储存每个地窖能否通行，使用邻接矩阵，就是图的那个数据结构。我们把它命名为$ m $。  
还有就是一维数组$ f $，储存对于每个地窖，最多地雷数量。  
最后是一个一维数组$ d $，储存路径。

经过分析，整个程序的大致框架已经出来了。接下来就是敲代码了。

# 源代码
```C++
#include<iostream> 
#include<algorithm>
using namespace std;

int n;
int c[201]={0};
bool m[201][201]={false};
int f[201]={0};
int d[201]={0};

int main(){
	int i,j;
	cin>>n;
	for(i=1;i<=n;i++){
		cin>>c[i];
	}
	while(1){
		int na,nb;
		cin>>na>>nb;
		if(!na&&!nb){
			break;
		}
		m[na][nb]=true;
	}
	f[n]=c[n];
	d[n]=0;
	int k,h;
	for(i=n-1;i>=1;i--){
		k=0;h=0;
		for(j=i+1;j<=n;j++){
			if(m[i][j]&&k<f[j]){
				k=f[j];
				h=j;
			}
		}
		f[i]=c[i]+k;
		d[i]=h;
	}
	k=f[1];h=1;
	for(i=2;i<=n;i++){
		if(f[i]>k){
			k=f[i];
			h=i;
		}
	}
	cout<<h;
	h=d[h];
	while(h!=0){
		cout<<"-"<<h;
		h=d[h];
	}
	cout<<endl<<k;
}

```

