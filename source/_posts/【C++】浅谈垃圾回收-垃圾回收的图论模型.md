---
title: 【C++】浅谈垃圾回收：垃圾回收的图论模型
comments: true
mathjax: true
date: 2019-10-04 23:05:00
tags:
 - C++
 - 垃圾回收
 - 图论
 - 标记算法
 - 智能指针
categories: C++
---

垃圾回收，可以说是现代语言一个必需的标准。自从`Lisp`问世以来，`GC`就走进了人们的视野。可惜的是，`C++`依然没有标准的`GC`实现，这使得基于`C++`的项目的开发效率大打折扣。并且人工管理内存极容易出错，而使用`RAII`又在一定程度上增加了对对象结构层次进行管理的难度。
所以本系列文章就是为了解决这个难题，为`C++`造一个`GC`。
<!-- more -->

# 主流的垃圾回收算法

一般来讲，`GC`算法分为这两大类：

- **引用计数类**算法
- **标记**算法

其中，`引用计数`算法是大家最熟悉的`GC`算法，`C++`的`std::shared_ptr<T>`就是一个典型的例子。以及在`Python`中，`引用计数`也有被用在部分的垃圾回收中。`引用计数`算法的缺点就是无法解决循环引用的问题。比如下面这个例子：

![](/images/posts/3d23f17-1.png)

对象A和对象B互相引用，它们的引用计数都为1，但实际上，它们都不可能被引用到。这就造成了内存泄漏。

我们再看标记算法。标记算法是以标记对象为核心，每次进行一次遍历，能够遍历到的对象都打上标记，最后删除没有标记的对象。标记算法还分为多种，比如标记清除、标记整理等，还可以有各种优化，比如分代回收。这里不会提到太多，因为这不是本文的重点。

# 标记清除算法的图论模型

标记的算法有很多，我就用最经典的`标记清除`算法来讲如何**用图论来看`垃圾回收`**。

我们知道，对象之间的引用是单向的（即使用一个指针或者引用时只能是一个调用另一个，不能互相调用），所以，这就可以用一个**有向图**来表示，每个对象都是一个结点。我们一般的对象结构都是一个`DAG`（有向无环图），没有存在环，就意味着没有循环引用，这种对象结构就可以使用引用计数类的算法管理。

![](/images/posts/3d23f17-2.png)

为了方便，我们称在栈中被引用到的结点为起始结点。对于一个对象来说，如果它不是在栈中被引用，那么这个对象是否存活就与图的连通性有关。**如果这个对象是存活的，就必然存在一条从起始结点到它的简单路径。这可以算是标记垃圾回收算法的核心思想。**找一条简单路径，用`DFS`（深度优先搜索）或者`BFS`（广度优先搜索）。这也就是为什么可以用`DFS`遍历对象打标记的原因。

![](/images/posts/3d23f17-3.png)

# 引用计数算法的图论模型

讲完了标记清除，现在我们再看一看引用计数。引用计数统计的是对象的被引用的次数，在图论中，其实就是结点的入度。但是入度的统计在非`DAG`图中就不可行了。如果有两个对象互相引用，并且已经无法被其它结点引用到，在标记算法中，这两个结点就会因为没有被打上标记而被回收。但是引用计数算法中，两个结点入度都为1，因此都不会删除对方。想要回收这两个对象，只有删除其中一个结点，但是，已经没有任何除它们之外的结点可以引用到它们了，自然就造成了内存泄漏。

# 标记算法与引用计数算法的比较

引用计数一个显著的优点就是它能够快速的回收垃圾对象，没有延迟，并且实现简单。而标记算法的语言级别实现往往需要`反射`或者`RTTI`的帮助才可以实现，否则`GC`出错的概率就会很高。目前，`C++`的成熟的语言级别实现`GC`就是`C++/CLI`了，但这和`ISO C++`的标准不一样（`C++/CLI`是`ECMA`标准），很难达到与其兼容。当然，标记算法有另外一个优点，它可以适用各种情况，实现灵活，在有非常多对象时，它比引用计数算法更加高效，因为引用计数算法在处理对象存活时的计数加减计算负担更重。所以，在我看来，标记算法更适合`GC`使用。

下一篇文章，我将会写一个标记清除的`GC`。项目地址：[markGC](https://github.com/ctj12461/markGC/)